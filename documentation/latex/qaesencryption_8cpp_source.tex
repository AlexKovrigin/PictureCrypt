\hypertarget{qaesencryption_8cpp_source}{}\section{qaesencryption.\+cpp}
\label{qaesencryption_8cpp_source}\index{C\+:/\+Users/salex/\+Documents/\+Git\+Hub/\+Picture\+Crypt/aes/qaesencryption.\+cpp@{C\+:/\+Users/salex/\+Documents/\+Git\+Hub/\+Picture\+Crypt/aes/qaesencryption.\+cpp}}

\begin{DoxyCode}
00001 \textcolor{preprocessor}{#include "\mbox{\hyperlink{qaesencryption_8h}{qaesencryption.h}}"}
00002 
00003 \textcolor{comment}{/*}
00004 \textcolor{comment}{ * Static Functions}
00005 \textcolor{comment}{ * */}
\Hypertarget{qaesencryption_8cpp_source_l00006}\mbox{\hyperlink{class_q_a_e_s_encryption_a43819eeb6a7cb29fbd3cb6ad640dcbdf}{00006}} QByteArray \mbox{\hyperlink{class_q_a_e_s_encryption_a43819eeb6a7cb29fbd3cb6ad640dcbdf}{QAESEncryption::Crypt}}(\mbox{\hyperlink{class_q_a_e_s_encryption_abe48208f4f6c7d68e6a10b49b9d0b7bd}{QAESEncryption::Aes}} level, 
      \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255}{QAESEncryption::Mode}} \mbox{\hyperlink{namespacetests-setup_a04126d10edec6b3171e1b55a00309b23}{mode}}, \textcolor{keyword}{const} QByteArray &rawText,
00007                                  \textcolor{keyword}{const} QByteArray &\mbox{\hyperlink{namespace_errors_dict_setup_a09c268098d09ffb8e5504f30fa6d5dd9}{key}}, \textcolor{keyword}{const} QByteArray &iv, 
      \mbox{\hyperlink{class_q_a_e_s_encryption_ab0a65cdea4eac21ef32530010d1b0247}{QAESEncryption::Padding}} padding)
00008 \{
00009     \textcolor{keywordflow}{return} \mbox{\hyperlink{class_q_a_e_s_encryption_aeac0ee8532e69e5d30b023fe38c30b3b}{QAESEncryption}}(level, \mbox{\hyperlink{namespacetests-setup_a04126d10edec6b3171e1b55a00309b23}{mode}}, padding).encode(rawText, 
      \mbox{\hyperlink{namespace_errors_dict_setup_a09c268098d09ffb8e5504f30fa6d5dd9}{key}}, iv);
00010 \}
00011 
\Hypertarget{qaesencryption_8cpp_source_l00012}\mbox{\hyperlink{class_q_a_e_s_encryption_af9baa154a06683049d941bd06ac698fd}{00012}} QByteArray \mbox{\hyperlink{class_q_a_e_s_encryption_af9baa154a06683049d941bd06ac698fd}{QAESEncryption::Decrypt}}(\mbox{\hyperlink{class_q_a_e_s_encryption_abe48208f4f6c7d68e6a10b49b9d0b7bd}{QAESEncryption::Aes}} level, 
      \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255}{QAESEncryption::Mode}} \mbox{\hyperlink{namespacetests-setup_a04126d10edec6b3171e1b55a00309b23}{mode}}, \textcolor{keyword}{const} QByteArray &rawText,
00013                                    \textcolor{keyword}{const} QByteArray &\mbox{\hyperlink{namespace_errors_dict_setup_a09c268098d09ffb8e5504f30fa6d5dd9}{key}}, \textcolor{keyword}{const} QByteArray &iv, 
      \mbox{\hyperlink{class_q_a_e_s_encryption_ab0a65cdea4eac21ef32530010d1b0247}{QAESEncryption::Padding}} padding)
00014 \{
00015      \textcolor{keywordflow}{return} \mbox{\hyperlink{class_q_a_e_s_encryption_aeac0ee8532e69e5d30b023fe38c30b3b}{QAESEncryption}}(level, \mbox{\hyperlink{namespacetests-setup_a04126d10edec6b3171e1b55a00309b23}{mode}}, padding).decode(rawText, 
      \mbox{\hyperlink{namespace_errors_dict_setup_a09c268098d09ffb8e5504f30fa6d5dd9}{key}}, iv);
00016 \}
00017 
\Hypertarget{qaesencryption_8cpp_source_l00018}\mbox{\hyperlink{class_q_a_e_s_encryption_a2112456e057e6dd886694348fbf202cd}{00018}} QByteArray \mbox{\hyperlink{class_q_a_e_s_encryption_a2112456e057e6dd886694348fbf202cd}{QAESEncryption::ExpandKey}}(
      \mbox{\hyperlink{class_q_a_e_s_encryption_abe48208f4f6c7d68e6a10b49b9d0b7bd}{QAESEncryption::Aes}} level, \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255}{QAESEncryption::Mode}} 
      \mbox{\hyperlink{namespacetests-setup_a04126d10edec6b3171e1b55a00309b23}{mode}}, \textcolor{keyword}{const} QByteArray &\mbox{\hyperlink{namespace_errors_dict_setup_a09c268098d09ffb8e5504f30fa6d5dd9}{key}})
00019 \{
00020      \textcolor{keywordflow}{return} \mbox{\hyperlink{class_q_a_e_s_encryption_aeac0ee8532e69e5d30b023fe38c30b3b}{QAESEncryption}}(level, \mbox{\hyperlink{namespacetests-setup_a04126d10edec6b3171e1b55a00309b23}{mode}}).expandKey(\mbox{\hyperlink{namespace_errors_dict_setup_a09c268098d09ffb8e5504f30fa6d5dd9}{key}});
00021 \}
00022 
\Hypertarget{qaesencryption_8cpp_source_l00023}\mbox{\hyperlink{class_q_a_e_s_encryption_abb2887bf5623a74053dd19627f3d3055}{00023}} QByteArray \mbox{\hyperlink{class_q_a_e_s_encryption_abb2887bf5623a74053dd19627f3d3055}{QAESEncryption::RemovePadding}}(\textcolor{keyword}{const} QByteArray &rawText, 
      \mbox{\hyperlink{class_q_a_e_s_encryption_ab0a65cdea4eac21ef32530010d1b0247}{QAESEncryption::Padding}} padding)
00024 \{
00025     QByteArray ret(rawText);
00026     \textcolor{keywordflow}{switch} (padding)
00027     \{
00028     \textcolor{keywordflow}{case} Padding::ZERO:
00029         \textcolor{comment}{//Works only if the last byte of the decoded array is not zero}
00030         \textcolor{keywordflow}{while} (ret.at(ret.length()-1) == 0x00)
00031             ret.remove(ret.length()-1, 1);
00032         \textcolor{keywordflow}{break};
00033     \textcolor{keywordflow}{case} Padding::PKCS7:
00034         ret.remove(ret.length() - ret.at(ret.length()-1), ret.at(ret.length()-1));
00035         \textcolor{keywordflow}{break};
00036     \textcolor{keywordflow}{case} Padding::ISO:
00037         ret.truncate(ret.lastIndexOf(0x80));
00038         \textcolor{keywordflow}{break};
00039     \textcolor{keywordflow}{default}:
00040         \textcolor{comment}{//do nothing}
00041         \textcolor{keywordflow}{break};
00042     \}
00043     \textcolor{keywordflow}{return} ret;
00044 \}
00045 \textcolor{comment}{/*}
00046 \textcolor{comment}{ * End Static function declarations}
00047 \textcolor{comment}{ * */}
00048 
00049 \textcolor{comment}{/*}
00050 \textcolor{comment}{ * Inline Functions}
00051 \textcolor{comment}{ * */}
00052 
\Hypertarget{qaesencryption_8cpp_source_l00053}\mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{00053}} \textcolor{keyword}{inline} quint8 \mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}(quint8 x)\{
00054   \textcolor{keywordflow}{return} ((x<<1) ^ (((x>>7) & 1) * 0x1b));
00055 \}
00056 
\Hypertarget{qaesencryption_8cpp_source_l00057}\mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{00057}} \textcolor{keyword}{inline} quint8 \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(quint8 x, quint8 y)\{
00058   \textcolor{keywordflow}{return} (((y & 1) * x) ^ ((y>>1 & 1) * \mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}(x)) ^ ((y>>2 & 1) * \mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}(
      \mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}(x))) ^ ((y>>3 & 1)
00059             * \mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}(\mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}(\mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}(x)))) ^ ((y>>4 & 1) * \mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}(
      \mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}(\mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}(\mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}(x))))));
00060 \}
00061 
00062 \textcolor{comment}{/*}
00063 \textcolor{comment}{ * End Inline functions}
00064 \textcolor{comment}{ * */}
00065 
00066 
\Hypertarget{qaesencryption_8cpp_source_l00067}\mbox{\hyperlink{class_q_a_e_s_encryption_aeac0ee8532e69e5d30b023fe38c30b3b}{00067}} \mbox{\hyperlink{class_q_a_e_s_encryption_aeac0ee8532e69e5d30b023fe38c30b3b}{QAESEncryption::QAESEncryption}}(\mbox{\hyperlink{class_q_a_e_s_encryption_abe48208f4f6c7d68e6a10b49b9d0b7bd}{Aes}} level, \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255}{Mode}} 
      \mbox{\hyperlink{namespacetests-setup_a04126d10edec6b3171e1b55a00309b23}{mode}},
00068                                \mbox{\hyperlink{class_q_a_e_s_encryption_ab0a65cdea4eac21ef32530010d1b0247}{Padding}} padding)
00069     : m\_nb(4), m\_blocklen(16), m\_level(level), m\_mode(\mbox{\hyperlink{namespacetests-setup_a04126d10edec6b3171e1b55a00309b23}{mode}}), m\_padding(padding)
00070 \{
00071     m\_state = NULL;
00072 
00073     \textcolor{keywordflow}{switch} (level)
00074     \{
00075     \textcolor{keywordflow}{case} \mbox{\hyperlink{class_q_a_e_s_encryption_abe48208f4f6c7d68e6a10b49b9d0b7bda0fa01cdf69e5537499ecfc6f96d6570a}{AES\_128}}: \{
00076         AES128 aes;
00077         m\_nk = aes.nk;
00078         m\_keyLen = aes.keylen;
00079         m\_nr = aes.nr;
00080         m\_expandedKey = aes.expandedKey;
00081         \}
00082         \textcolor{keywordflow}{break};
00083     \textcolor{keywordflow}{case} \mbox{\hyperlink{class_q_a_e_s_encryption_abe48208f4f6c7d68e6a10b49b9d0b7bda7bd082b240582de6d5f4b8ea604e646b}{AES\_192}}: \{
00084         AES192 aes;
00085         m\_nk = aes.nk;
00086         m\_keyLen = aes.keylen;
00087         m\_nr = aes.nr;
00088         m\_expandedKey = aes.expandedKey;
00089         \}
00090         \textcolor{keywordflow}{break};
00091     \textcolor{keywordflow}{case} \mbox{\hyperlink{class_q_a_e_s_encryption_abe48208f4f6c7d68e6a10b49b9d0b7bdacde97774ab1d4c609e04b0dd13a1e1f7}{AES\_256}}: \{
00092         AES256 aes;
00093         m\_nk = aes.nk;
00094         m\_keyLen = aes.keylen;
00095         m\_nr = aes.nr;
00096         m\_expandedKey = aes.expandedKey;
00097         \}
00098         \textcolor{keywordflow}{break};
00099     \textcolor{keywordflow}{default}: \{
00100         AES128 aes;
00101         m\_nk = aes.nk;
00102         m\_keyLen = aes.keylen;
00103         m\_nr = aes.nr;
00104         m\_expandedKey = aes.expandedKey;
00105         \}
00106         \textcolor{keywordflow}{break};
00107     \}
00108 
00109 \}
00110 QByteArray QAESEncryption::getPadding(\textcolor{keywordtype}{int} currSize, \textcolor{keywordtype}{int} alignment)
00111 \{
00112     \textcolor{keywordtype}{int} size = (alignment - currSize % alignment) % alignment;
00113     \textcolor{keywordflow}{if} (size == 0) \textcolor{keywordflow}{return} QByteArray();
00114     \textcolor{keywordflow}{switch}(m\_padding)
00115     \{
00116     \textcolor{keywordflow}{case} Padding::ZERO:
00117         \textcolor{keywordflow}{return} QByteArray(size, 0x00);
00118         \textcolor{keywordflow}{break};
00119     \textcolor{keywordflow}{case} Padding::PKCS7:
00120         \textcolor{keywordflow}{return} QByteArray(size,size);
00121         \textcolor{keywordflow}{break};
00122     \textcolor{keywordflow}{case} Padding::ISO:
00123         \textcolor{keywordflow}{return} QByteArray (size-1, 0x00).prepend(0x80);
00124         \textcolor{keywordflow}{break};
00125     \textcolor{keywordflow}{default}:
00126         \textcolor{keywordflow}{return} QByteArray(size, 0x00);
00127         \textcolor{keywordflow}{break};
00128     \}
00129     \textcolor{keywordflow}{return} QByteArray(size, 0x00);
00130 \}
00131 
\Hypertarget{qaesencryption_8cpp_source_l00132}\mbox{\hyperlink{class_q_a_e_s_encryption_a5bfbb972f84a8376fceed648553c0912}{00132}} QByteArray \mbox{\hyperlink{class_q_a_e_s_encryption_a5bfbb972f84a8376fceed648553c0912}{QAESEncryption::expandKey}}(\textcolor{keyword}{const} QByteArray &
      \mbox{\hyperlink{namespace_errors_dict_setup_a09c268098d09ffb8e5504f30fa6d5dd9}{key}})
00133 \{
00134   \textcolor{keywordtype}{int} i, k;
00135   quint8 tempa[4]; \textcolor{comment}{// Used for the column/row operations}
00136   QByteArray roundKey(\mbox{\hyperlink{namespace_errors_dict_setup_a09c268098d09ffb8e5504f30fa6d5dd9}{key}});
00137 
00138   \textcolor{comment}{// The first round key is the key itself.}
00139   \textcolor{comment}{// ...}
00140 
00141   \textcolor{comment}{// All other round keys are found from the previous round keys.}
00142   \textcolor{comment}{//i == Nk}
00143   \textcolor{keywordflow}{for}(i = m\_nk; i < m\_nb * (m\_nr + 1); i++)
00144   \{
00145     tempa[0] = (quint8) roundKey.at((i-1) * 4 + 0);
00146     tempa[1] = (quint8) roundKey.at((i-1) * 4 + 1);
00147     tempa[2] = (quint8) roundKey.at((i-1) * 4 + 2);
00148     tempa[3] = (quint8) roundKey.at((i-1) * 4 + 3);
00149 
00150     \textcolor{keywordflow}{if} (i % m\_nk == 0)
00151     \{
00152         \textcolor{comment}{// This function shifts the 4 bytes in a word to the left once.}
00153         \textcolor{comment}{// [a0,a1,a2,a3] becomes [a1,a2,a3,a0]}
00154 
00155         \textcolor{comment}{// Function RotWord()}
00156         k = tempa[0];
00157         tempa[0] = tempa[1];
00158         tempa[1] = tempa[2];
00159         tempa[2] = tempa[3];
00160         tempa[3] = k;
00161 
00162         \textcolor{comment}{// Function Subword()}
00163         tempa[0] = getSBoxValue(tempa[0]);
00164         tempa[1] = getSBoxValue(tempa[1]);
00165         tempa[2] = getSBoxValue(tempa[2]);
00166         tempa[3] = getSBoxValue(tempa[3]);
00167 
00168         tempa[0] =  tempa[0] ^ Rcon[i/m\_nk];
00169     \}
00170     \textcolor{keywordflow}{if} (m\_level == \mbox{\hyperlink{class_q_a_e_s_encryption_abe48208f4f6c7d68e6a10b49b9d0b7bdacde97774ab1d4c609e04b0dd13a1e1f7}{AES\_256}} && i % m\_nk == 4)
00171     \{
00172         \textcolor{comment}{// Function Subword()}
00173         tempa[0] = getSBoxValue(tempa[0]);
00174         tempa[1] = getSBoxValue(tempa[1]);
00175         tempa[2] = getSBoxValue(tempa[2]);
00176         tempa[3] = getSBoxValue(tempa[3]);
00177     \}
00178     roundKey.insert(i * 4 + 0, (quint8) roundKey.at((i - m\_nk) * 4 + 0) ^ tempa[0]);
00179     roundKey.insert(i * 4 + 1, (quint8) roundKey.at((i - m\_nk) * 4 + 1) ^ tempa[1]);
00180     roundKey.insert(i * 4 + 2, (quint8) roundKey.at((i - m\_nk) * 4 + 2) ^ tempa[2]);
00181     roundKey.insert(i * 4 + 3, (quint8) roundKey.at((i - m\_nk) * 4 + 3) ^ tempa[3]);
00182   \}
00183   \textcolor{keywordflow}{return} roundKey;
00184 \}
00185 
00186 \textcolor{comment}{// This function adds the round key to state.}
00187 \textcolor{comment}{// The round key is added to the state by an XOR function.}
00188 \textcolor{keywordtype}{void} QAESEncryption::addRoundKey(\textcolor{keyword}{const} quint8 round, \textcolor{keyword}{const} QByteArray expKey)
00189 \{
00190   QByteArray::iterator it = m\_state->begin();
00191   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i < 16; ++i)
00192       it[i] = (quint8) it[i] ^ (quint8) expKey.at(round * m\_nb * 4 + (i/4) * m\_nb + (i%4));
00193 \}
00194 
00195 \textcolor{comment}{// The SubBytes Function Substitutes the values in the}
00196 \textcolor{comment}{// state matrix with values in an S-box.}
00197 \textcolor{keywordtype}{void} QAESEncryption::subBytes()
00198 \{
00199   QByteArray::iterator it = m\_state->begin();
00200   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 16; i++)
00201     it[i] = getSBoxValue((quint8) it[i]);
00202 \}
00203 
00204 \textcolor{comment}{// The ShiftRows() function shifts the rows in the state to the left.}
00205 \textcolor{comment}{// Each row is shifted with different offset.}
00206 \textcolor{comment}{// Offset = Row number. So the first row is not shifted.}
00207 \textcolor{keywordtype}{void} QAESEncryption::shiftRows()
00208 \{
00209     QByteArray::iterator it = m\_state->begin();
00210     quint8 temp;
00211     \textcolor{comment}{//Keep in mind that QByteArray is column-driven!!}
00212 
00213      \textcolor{comment}{//Shift 1 to left}
00214     temp   = (quint8)it[1];
00215     it[1]  = (quint8)it[5];
00216     it[5]  = (quint8)it[9];
00217     it[9]  = (quint8)it[13];
00218     it[13] = (quint8)temp;
00219 
00220     \textcolor{comment}{//Shift 2 to left}
00221     temp   = (quint8)it[2];
00222     it[2]  = (quint8)it[10];
00223     it[10] = (quint8)temp;
00224     temp   = (quint8)it[6];
00225     it[6]  = (quint8)it[14];
00226     it[14] = (quint8)temp;
00227 
00228     \textcolor{comment}{//Shift 3 to left}
00229     temp   = (quint8)it[3];
00230     it[3]  = (quint8)it[15];
00231     it[15] = (quint8)it[11];
00232     it[11] = (quint8)it[7];
00233     it[7]  = (quint8)temp;
00234 \}
00235 
00236 \textcolor{comment}{// MixColumns function mixes the columns of the state matrix}
00237 \textcolor{comment}{//optimized!!}
00238 \textcolor{keywordtype}{void} QAESEncryption::mixColumns()
00239 \{
00240   QByteArray::iterator it = m\_state->begin();
00241   quint8 tmp, tm, t;
00242 
00243   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 16; i += 4)\{
00244     t       = (quint8)it[i];
00245     tmp     =  (quint8)it[i] ^ (quint8)it[i+1] ^ (quint8)it[i+2] ^ (quint8)it[i+3] ;
00246 
00247     tm      = \mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}( (quint8)it[i] ^ (quint8)it[i+1] );
00248     it[i]   = (quint8)it[i] ^ (quint8)tm ^ (quint8)tmp;
00249 
00250     tm      = \mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}( (quint8)it[i+1] ^ (quint8)it[i+2]);
00251     it[i+1] = (quint8)it[i+1] ^ (quint8)tm ^ (quint8)tmp;
00252 
00253     tm      = \mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}( (quint8)it[i+2] ^ (quint8)it[i+3]);
00254     it[i+2] =(quint8)it[i+2] ^ (quint8)tm ^ (quint8)tmp;
00255 
00256     tm      = \mbox{\hyperlink{qaesencryption_8cpp_a94a5c6f286db021d028ddc6f91a65f72}{xTime}}((quint8)it[i+3] ^ (quint8)t);
00257     it[i+3] =(quint8)it[i+3] ^ (quint8)tm ^ (quint8)tmp;
00258   \}
00259 \}
00260 
00261 \textcolor{comment}{// MixColumns function mixes the columns of the state matrix.}
00262 \textcolor{comment}{// The method used to multiply may be difficult to understand for the inexperienced.}
00263 \textcolor{comment}{// Please use the references to gain more information.}
00264 \textcolor{keywordtype}{void} QAESEncryption::invMixColumns()
00265 \{
00266   QByteArray::iterator it = m\_state->begin();
00267   quint8 a,b,c,d;
00268   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 16; i+=4)\{
00269     a = (quint8) it[i];
00270     b = (quint8) it[i+1];
00271     c = (quint8) it[i+2];
00272     d = (quint8) it[i+3];
00273 
00274     it[i]   = (quint8) (\mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(a, 0x0e) ^ \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(b, 0x0b) ^ 
      \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(c, 0x0d) ^ \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(d, 0x09));
00275     it[i+1] = (quint8) (\mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(a, 0x09) ^ \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(b, 0x0e) ^ 
      \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(c, 0x0b) ^ \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(d, 0x0d));
00276     it[i+2] = (quint8) (\mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(a, 0x0d) ^ \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(b, 0x09) ^ 
      \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(c, 0x0e) ^ \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(d, 0x0b));
00277     it[i+3] = (quint8) (\mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(a, 0x0b) ^ \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(b, 0x0d) ^ 
      \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(c, 0x09) ^ \mbox{\hyperlink{qaesencryption_8cpp_adcc23c7a5520793f14710fff6ef23dfe}{multiply}}(d, 0x0e));
00278   \}
00279 \}
00280 
00281 \textcolor{comment}{// The SubBytes Function Substitutes the values in the}
00282 \textcolor{comment}{// state matrix with values in an S-box.}
00283 \textcolor{keywordtype}{void} QAESEncryption::invSubBytes()
00284 \{
00285     QByteArray::iterator it = m\_state->begin();
00286     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 16; ++i)
00287         it[i] = getSBoxInvert((quint8) it[i]);
00288 \}
00289 
00290 \textcolor{keywordtype}{void} QAESEncryption::invShiftRows()
00291 \{
00292     QByteArray::iterator it = m\_state->begin();
00293     uint8\_t temp;
00294 
00295     \textcolor{comment}{//Keep in mind that QByteArray is column-driven!!}
00296 
00297     \textcolor{comment}{//Shift 1 to right}
00298     temp   = (quint8)it[13];
00299     it[13] = (quint8)it[9];
00300     it[9]  = (quint8)it[5];
00301     it[5]  = (quint8)it[1];
00302     it[1]  = (quint8)temp;
00303 
00304     \textcolor{comment}{//Shift 2}
00305     temp   = (quint8)it[10];
00306     it[10] = (quint8)it[2];
00307     it[2]  = (quint8)temp;
00308     temp   = (quint8)it[14];
00309     it[14] = (quint8)it[6];
00310     it[6]  = (quint8)temp;
00311 
00312     \textcolor{comment}{//Shift 3}
00313     temp   = (quint8)it[15];
00314     it[15] = (quint8)it[3];
00315     it[3]  = (quint8)it[7];
00316     it[7]  = (quint8)it[11];
00317     it[11] = (quint8)temp;
00318 \}
00319 
00320 QByteArray QAESEncryption::byteXor(\textcolor{keyword}{const} QByteArray &a, \textcolor{keyword}{const} QByteArray &b)
00321 \{
00322   QByteArray::const\_iterator it\_a = a.begin();
00323   QByteArray::const\_iterator it\_b = b.begin();
00324   QByteArray ret;
00325 
00326   \textcolor{comment}{//for(int i = 0; i < m\_blocklen; i++)}
00327   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < std::min(a.size(), b.size()); i++)
00328       ret.insert(i,it\_a[i] ^ it\_b[i]);
00329 
00330   \textcolor{keywordflow}{return} ret;
00331 \}
00332 
00333 \textcolor{comment}{// Cipher is the main function that encrypts the PlainText.}
00334 QByteArray QAESEncryption::cipher(\textcolor{keyword}{const} QByteArray &expKey, \textcolor{keyword}{const} QByteArray &in)
00335 \{
00336 
00337   \textcolor{comment}{//m\_state is the input buffer...}
00338   QByteArray output(in);
00339   m\_state = &output;
00340 
00341   \textcolor{comment}{// Add the First round key to the state before starting the rounds.}
00342   addRoundKey(0, expKey);
00343 
00344   \textcolor{comment}{// There will be Nr rounds.}
00345   \textcolor{comment}{// The first Nr-1 rounds are identical.}
00346   \textcolor{comment}{// These Nr-1 rounds are executed in the loop below.}
00347   \textcolor{keywordflow}{for}(quint8 round = 1; round < m\_nr; ++round)\{
00348     subBytes();
00349     shiftRows();
00350     mixColumns();
00351     addRoundKey(round, expKey);
00352   \}
00353 
00354   \textcolor{comment}{// The last round is given below.}
00355   \textcolor{comment}{// The MixColumns function is not here in the last round.}
00356   subBytes();
00357   shiftRows();
00358   addRoundKey(m\_nr, expKey);
00359 
00360   \textcolor{keywordflow}{return} output;
00361 \}
00362 
00363 QByteArray QAESEncryption::invCipher(\textcolor{keyword}{const} QByteArray &expKey, \textcolor{keyword}{const} QByteArray &in)
00364 \{
00365     \textcolor{comment}{//m\_state is the input buffer.... handle it!}
00366     QByteArray output(in);
00367     m\_state = &output;
00368 
00369     \textcolor{comment}{// Add the First round key to the state before starting the rounds.}
00370     addRoundKey(m\_nr, expKey);
00371 
00372     \textcolor{comment}{// There will be Nr rounds.}
00373     \textcolor{comment}{// The first Nr-1 rounds are identical.}
00374     \textcolor{comment}{// These Nr-1 rounds are executed in the loop below.}
00375     \textcolor{keywordflow}{for}(quint8 round=m\_nr-1; round>0 ; round--)\{
00376         invShiftRows();
00377         invSubBytes();
00378         addRoundKey(round, expKey);
00379         invMixColumns();
00380     \}
00381 
00382     \textcolor{comment}{// The last round is given below.}
00383     \textcolor{comment}{// The MixColumns function is not here in the last round.}
00384     invShiftRows();
00385     invSubBytes();
00386     addRoundKey(0, expKey);
00387 
00388     \textcolor{keywordflow}{return} output;
00389 \}
00390 
\Hypertarget{qaesencryption_8cpp_source_l00391}\mbox{\hyperlink{class_q_a_e_s_encryption_a0c56eddd6f03e93b1f7faad464044d65}{00391}} QByteArray \mbox{\hyperlink{class_q_a_e_s_encryption_a0c56eddd6f03e93b1f7faad464044d65}{QAESEncryption::encode}}(\textcolor{keyword}{const} QByteArray &rawText, \textcolor{keyword}{const} QByteArray &
      \mbox{\hyperlink{namespace_errors_dict_setup_a09c268098d09ffb8e5504f30fa6d5dd9}{key}}, \textcolor{keyword}{const} QByteArray &iv)
00392 \{
00393     \textcolor{keywordflow}{if} (m\_mode >= \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255a559bffc55d3599d0a172cc85aed98966}{CBC}} && (iv.isNull() || iv.size() != m\_blocklen))
00394        \textcolor{keywordflow}{return} QByteArray();
00395 
00396     QByteArray ret;
00397     QByteArray expandedKey = \mbox{\hyperlink{class_q_a_e_s_encryption_a5bfbb972f84a8376fceed648553c0912}{expandKey}}(\mbox{\hyperlink{namespace_errors_dict_setup_a09c268098d09ffb8e5504f30fa6d5dd9}{key}});
00398     QByteArray alignedText(rawText);
00399 
00400     \textcolor{comment}{//Fill array with padding}
00401     alignedText.append(getPadding(rawText.size(), m\_blocklen));
00402 
00403     \textcolor{keywordflow}{switch}(m\_mode)
00404     \{
00405     \textcolor{keywordflow}{case} \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255a4ca7f51778e2adf1f464164a0ba8e75e}{ECB}}:
00406         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i < alignedText.size(); i+= m\_blocklen)
00407             ret.append(cipher(expandedKey, alignedText.mid(i, m\_blocklen)));
00408         \textcolor{keywordflow}{break};
00409     \textcolor{keywordflow}{case} \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255a559bffc55d3599d0a172cc85aed98966}{CBC}}: \{
00410             QByteArray ivTemp(iv);
00411             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i < alignedText.size(); i+= m\_blocklen) \{
00412                 alignedText.replace(i, m\_blocklen, byteXor(alignedText.mid(i, m\_blocklen),ivTemp));
00413                 ret.append(cipher(expandedKey, alignedText.mid(i, m\_blocklen)));
00414                 ivTemp = ret.mid(i, m\_blocklen);
00415             \}
00416         \}
00417         \textcolor{keywordflow}{break};
00418     \textcolor{keywordflow}{case} \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255ae5e2e019df35c7d172fcd7f0ebec5e8e}{CFB}}: \{
00419             ret.append(byteXor(alignedText.left(m\_blocklen), cipher(expandedKey, iv)));
00420             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i < alignedText.size(); i+= m\_blocklen) \{
00421                 \textcolor{keywordflow}{if} (i+m\_blocklen < alignedText.size())
00422                     ret.append(byteXor(alignedText.mid(i+m\_blocklen, m\_blocklen),
00423                                        cipher(expandedKey, ret.mid(i, m\_blocklen))));
00424             \}
00425         \}
00426         \textcolor{keywordflow}{break};
00427     \textcolor{keywordflow}{case} \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255a27e2f82decd94080893d61db4a8adcb3}{OFB}}: \{
00428             QByteArray ofbTemp;
00429             ofbTemp.append(cipher(expandedKey, iv));
00430             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=m\_blocklen; i < alignedText.size(); i += m\_blocklen)\{
00431                 ofbTemp.append(cipher(expandedKey, ofbTemp.right(m\_blocklen)));
00432             \}
00433             ret.append(byteXor(alignedText, ofbTemp));
00434         \}
00435         \textcolor{keywordflow}{break};
00436     \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};
00437     \}
00438     \textcolor{keywordflow}{return} ret;
00439 \}
00440 
\Hypertarget{qaesencryption_8cpp_source_l00441}\mbox{\hyperlink{class_q_a_e_s_encryption_a58f972f2b66c2454edd5112495463bba}{00441}} QByteArray \mbox{\hyperlink{class_q_a_e_s_encryption_a58f972f2b66c2454edd5112495463bba}{QAESEncryption::decode}}(\textcolor{keyword}{const} QByteArray &rawText, \textcolor{keyword}{const} QByteArray &
      \mbox{\hyperlink{namespace_errors_dict_setup_a09c268098d09ffb8e5504f30fa6d5dd9}{key}}, \textcolor{keyword}{const} QByteArray &iv)
00442 \{
00443     \textcolor{keywordflow}{if} (m\_mode >= \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255a559bffc55d3599d0a172cc85aed98966}{CBC}} && (iv.isNull() || iv.size() != m\_blocklen))
00444        \textcolor{keywordflow}{return} QByteArray();
00445 
00446     QByteArray ret;
00447     QByteArray expandedKey = \mbox{\hyperlink{class_q_a_e_s_encryption_a5bfbb972f84a8376fceed648553c0912}{expandKey}}(\mbox{\hyperlink{namespace_errors_dict_setup_a09c268098d09ffb8e5504f30fa6d5dd9}{key}});
00448 
00449     \textcolor{keywordflow}{switch}(m\_mode)
00450     \{
00451     \textcolor{keywordflow}{case} \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255a4ca7f51778e2adf1f464164a0ba8e75e}{ECB}}:
00452         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i < rawText.size(); i+= m\_blocklen)
00453             ret.append(invCipher(expandedKey, rawText.mid(i, m\_blocklen)));
00454         \textcolor{keywordflow}{break};
00455     \textcolor{keywordflow}{case} \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255a559bffc55d3599d0a172cc85aed98966}{CBC}}: \{
00456             QByteArray ivTemp(iv);
00457             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i < rawText.size(); i+= m\_blocklen)\{
00458                 ret.append(invCipher(expandedKey, rawText.mid(i, m\_blocklen)));
00459                 ret.replace(i, m\_blocklen, byteXor(ret.mid(i, m\_blocklen),ivTemp));
00460                 ivTemp = rawText.mid(i, m\_blocklen);
00461             \}
00462         \}
00463         \textcolor{keywordflow}{break};
00464     \textcolor{keywordflow}{case} \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255ae5e2e019df35c7d172fcd7f0ebec5e8e}{CFB}}: \{
00465             ret.append(byteXor(rawText.mid(0, m\_blocklen), cipher(expandedKey, iv)));
00466             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i < rawText.size(); i+= m\_blocklen)\{
00467                 \textcolor{keywordflow}{if} (i+m\_blocklen < rawText.size()) \{
00468                     ret.append(byteXor(rawText.mid(i+m\_blocklen, m\_blocklen),
00469                                        cipher(expandedKey, rawText.mid(i, m\_blocklen))));
00470                 \}
00471             \}
00472         \}
00473         \textcolor{keywordflow}{break};
00474     \textcolor{keywordflow}{case} \mbox{\hyperlink{class_q_a_e_s_encryption_ad3e031c49a3d56566379d75b40b7b255a27e2f82decd94080893d61db4a8adcb3}{OFB}}: \{
00475         QByteArray ofbTemp;
00476         ofbTemp.append(cipher(expandedKey, iv));
00477         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=m\_blocklen; i < rawText.size(); i += m\_blocklen)\{
00478             ofbTemp.append(cipher(expandedKey, ofbTemp.right(m\_blocklen)));
00479         \}
00480         ret.append(byteXor(rawText, ofbTemp));
00481     \}
00482         \textcolor{keywordflow}{break};
00483     \textcolor{keywordflow}{default}:
00484         \textcolor{comment}{//do nothing}
00485         \textcolor{keywordflow}{break};
00486     \}
00487     \textcolor{keywordflow}{return} ret;
00488 \}
00489 
\Hypertarget{qaesencryption_8cpp_source_l00490}\mbox{\hyperlink{class_q_a_e_s_encryption_a4dc7e77485e5a3e63eebc99b9386c17b}{00490}} QByteArray \mbox{\hyperlink{class_q_a_e_s_encryption_a4dc7e77485e5a3e63eebc99b9386c17b}{QAESEncryption::removePadding}}(\textcolor{keyword}{const} QByteArray &rawText)
00491 \{
00492     QByteArray ret(rawText);
00493     \textcolor{keywordflow}{switch} (m\_padding)
00494     \{
00495     \textcolor{keywordflow}{case} Padding::ZERO:
00496         \textcolor{comment}{//Works only if the last byte of the decoded array is not zero}
00497         \textcolor{keywordflow}{while} (ret.at(ret.length()-1) == 0x00)
00498             ret.remove(ret.length()-1, 1);
00499         \textcolor{keywordflow}{break};
00500     \textcolor{keywordflow}{case} Padding::PKCS7:
00501         ret.remove(ret.length() - ret.at(ret.length()-1), ret.at(ret.length()-1));
00502         \textcolor{keywordflow}{break};
00503     \textcolor{keywordflow}{case} Padding::ISO:
00504         ret.truncate(ret.lastIndexOf(0x80));
00505         \textcolor{keywordflow}{break};
00506     \textcolor{keywordflow}{default}:
00507         \textcolor{comment}{//do nothing}
00508         \textcolor{keywordflow}{break};
00509     \}
00510     \textcolor{keywordflow}{return} ret;
00511 \}
\end{DoxyCode}
